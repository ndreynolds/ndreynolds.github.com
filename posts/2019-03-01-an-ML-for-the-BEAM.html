<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Ideas for an ML for the BEAM | Nick Reynolds</title>
    <link rel="stylesheet" href="../css/tufte.css" type="text/css" media="all" />
<link rel="stylesheet" href="../css/pandoc.css" type="text/css" media="all" />
<link rel="stylesheet" href="../css/pandoc-solarized.css" type="text/css" media="all" />
<link rel="stylesheet" href="../css/site.css" type="text/css" media="all" />
<script type="text/javascript" src="../js/life.js"></script>

  </head>
  <body>
    <article>
      <a href="../">&laquo; Home</a>

      <section>
        
<header>
<h1 class="title">Ideas for an ML for the BEAM</h1>


<p class="byline">March  1, 2019</p>

</header>


<p>This post covers some ideas I have on an ML-based language (something like Haskell, OCaml, Elm, etc.) that compiles to the BEAM bytecode—why I think we need one, analysis of existing projects, and strategies for embracing types while staying true to core Erlang ideas.</p>
<p><!--more--></p>
<p>Lately, I’ve been reasonably happy working with Elixir. For me, especially as someone who wrote a lot of Ruby, it’s mostly an improvement upon Erlang<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle" /><span class="sidenote">In my opinion, Elixir has better (or, at least, more modern) documentation and tooling. Mix and Hex have made for an incredibly smooth experience. The syntax is subjective. Elixir’s was more familiar to me, but I think there’s nothing wrong with Erlang’s pascal-cased variables and punctuation system; it’s just different. I love some Elixir additions such as <code>with</code> and <code>|&gt;</code>, and appreciate the reorganization of Erlang APIs into more coherent modules (e.g., <code>System</code> aggregates functionality from <code>os</code>, <code>erlang</code>, <code>init</code>, etc.). Some things are also worse. I dislike allowing variable rebinding (forbidden in Erlang), and I’m on the fence about macros—I’ve found them useful a few times (e.g., for DSLs), but they seem to be often abused and often make libraries unnecessarily hard to understand (particularly because of <code>use</code> / <code>__using__</code>).<br />
<br />
</span></span>.</p>
<p>But of course, Elixir also <em>is</em> Erlang. Both languages are backed by the Erlang Runtime System (the BEAM), and I think it’s the BEAM and other core concepts from Erlang—functional programming, the actor model, process monitoring &amp; supervision, system observability—that make both Elixir and Erlang truly great for building software systems.</p>
<p>It’s also why I don’t want to jump ship for something like Haskell, Scala or Rust. But I also have the feeling that the BEAM ecosystem is missing some great ideas from these languages, and for me the big one is types.</p>
<h1 id="why-the-beam-needs-an-ml">Why the BEAM needs an ML</h1>
<p>Types are the one tool I truly miss in BEAM languages. I also know I’m not the first in the community to realize this. Type systems are useful in a number of ways, by helping us to:</p>
<ul>
<li>Detect type errors in our code (e.g., <code>1 + 'a'</code>) that would otherwise surface as runtime type errors.</li>
<li>Refactor code with confidence that no type contracts were broken.</li>
<li>Create abstractions by composing types or assigning more descriptive names to generic types (e.g., <code>ApplicationState</code> vs. <code>Map</code>).</li>
<li>Supply documentation on a function’s usage that can be automatically checked.</li>
<li>Enable optimizations that are only possible when the set of possible arguments is restricted—e.g., <code>bool()</code> vs. <code>term()</code>.</li>
</ul>
<p>Erlang is certainly already ahead of other dynamic languages in some of these respects, and we already see some of these benefits. For example, trying to call an undefined function (wrong name or arity) results in a compilation error, whereas interpreted languages such as Ruby will first find the error when the particular code path is taken.</p>
<p>It’s even possible to define composable function and type specifications that are utilizied by documentation tools (e.g., EDoc, ExDoc) and can be checked by Dialyzer.</p>
<h1 id="existing-approaches">Existing Approaches</h1>
<h2 id="dialyzer">Dialyzer</h2>
<p>Dialyzer is a great Erlang tool (or “bug finder”) that performs static analysis of Erlang code<span><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle" /><span class="sidenote">And also of Elixir code, when it’s been first compiled down to Erlang.<br />
<br />
</span></span>. Dialyzer provides a type system based on “success typings”. The main difference between Dialyzer’s type system and typical static type systems (Haskell, Go, etc.) boils down to optimism vs. pessimism. Instead of trying to prove a program correct and failing if unable to do so, Dialyzer just tries to prove the program incorrect and passes if it’s unable to find any evidence that the program will definitely fail.</p>
<p>How Dialyzer Works</p>
<p>For example, consider the following module definition:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode erlang"><code class="sourceCode erlang"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">-module</span><span class="fu">(</span><span class="ch">dial1</span><span class="fu">).</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">-export</span><span class="fu">([</span><span class="ch">foo</span><span class="op">/</span><span class="dv">0</span><span class="fu">]).</span></a>
<a class="sourceLine" id="cb1-3" title="3"></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="fu">foo()</span> <span class="op">-&gt;</span> <span class="fu">add(</span><span class="dv">1</span><span class="fu">,</span> <span class="fu">{}).</span></a>
<a class="sourceLine" id="cb1-5" title="5"></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="fu">add(</span><span class="va">A</span><span class="fu">,</span> <span class="va">B</span><span class="fu">)</span> <span class="op">-&gt;</span> <span class="va">A</span> <span class="op">+</span> <span class="va">B</span><span class="fu">.</span></a></code></pre></div>
<p>When checked with <code>dialyzer dial1.erl</code><span><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle" /><span class="sidenote">First, you’ll need to have built a PLT (persistent lookup table) which caches analyses of applications for later use (in particular the ones included in Erlang/OTP). Run <code>dialyzer --build_plt --apps erts kernel stdlib</code> to build a minimal one.<br />
<br />
</span></span>, this produces the following warnings:</p>
<pre class="example"><code>dialyzer_test.erl:4: Function foo/0 has no local return
dialyzer_test.erl:4: The call dialyzer_test:add(1,{}) will never return since it differs in the 2nd argument from the success typing arguments: (number(),number())
dialyzer_test.erl:6: Function add/2 has no local return
dialyzer_test.erl:6: The call erlang:'+'(A::1,B::{}) will never return since it differs in the 2nd argument from the success typing arguments: (number(),number())
</code></pre>
<p>The call to <code>add/2</code> in <code>foo/0</code> is followed through to the call to <code>erlang:'+'/2</code>, which accepts two arguments, both of type <code>number()</code>. Because the second argument in the call is a tuple, dialyzer points out this contradiction and that the call will not return (fourth warning above). This failure to return also “bubbles up” in the call stack, which explains the somewhat confusing first three warnings.</p>
<p>Dialyzer also can use specs in order to constrain types in its analysis. In this way, specs are similar to optional type hints (or annotations) in other languages.</p>
<p>Even though <code>erlang:'+'/2</code> supports both integers and floats, we can constrain the <code>add/2</code> function spec to only accept integers:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode erlang"><code class="sourceCode erlang"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">-module</span><span class="fu">(</span><span class="ch">dial1</span><span class="fu">).</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">-export</span><span class="fu">([</span><span class="ch">foo</span><span class="op">/</span><span class="dv">0</span><span class="fu">]).</span></a>
<a class="sourceLine" id="cb3-3" title="3"></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="fu">foo()</span> <span class="op">-&gt;</span> <span class="fu">add(</span><span class="dv">1</span><span class="fu">,</span> <span class="fl">1.2</span><span class="fu">).</span></a>
<a class="sourceLine" id="cb3-5" title="5"></a>
<a class="sourceLine" id="cb3-6" title="6"><span class="op">-</span><span class="ch">spec</span> <span class="fu">add(integer(),</span> <span class="fu">integer())</span> <span class="op">-&gt;</span> <span class="fu">integer().</span></a>
<a class="sourceLine" id="cb3-7" title="7"><span class="fu">add(</span><span class="va">A</span><span class="fu">,</span> <span class="va">B</span><span class="fu">)</span> <span class="op">-&gt;</span> <span class="va">A</span> <span class="op">+</span> <span class="va">B</span><span class="fu">.</span></a></code></pre></div>
<p>Dialyzer produces the following warnings for the code above:</p>
<pre class="example"><code>dialyzer_test.erl:4: Function foo/0 has no local return
dialyzer_test.erl:4: The call dialyzer_test:add(1,float()) breaks the contract (integer(),integer()) -&gt; integer()
dialyzer_test.erl:6: Invalid type specification for function dialyzer_test:add/2. The success typing is (1,float()) -&gt; float()
</code></pre>
<p>It indicates the contradiction between our call and specification—either the call or our type specification is incorrect.</p>
<p>Dialyzer Limitations</p>
<p>Dialyzer never claims to be able to find all errors in your program, but this means that its analysis can often feel unsatisfying compared to static type analysis in other languages. Take the following example:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode erlang"><code class="sourceCode erlang"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">-module</span><span class="fu">(</span><span class="ch">dial2</span><span class="fu">).</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="kw">-export</span><span class="fu">([</span><span class="ch">next_status</span><span class="op">/</span><span class="dv">1</span><span class="fu">]).</span></a>
<a class="sourceLine" id="cb5-3" title="3"></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="op">-</span><span class="ch">type</span> <span class="fu">status()</span> <span class="fu">::</span> <span class="ch">processing</span> <span class="fu">|</span> <span class="ch">closed</span><span class="fu">.</span></a>
<a class="sourceLine" id="cb5-5" title="5"></a>
<a class="sourceLine" id="cb5-6" title="6"><span class="op">-</span><span class="ch">spec</span> <span class="fu">next_status(status())</span> <span class="op">-&gt;</span> <span class="fu">status().</span></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="fu">next_status(</span><span class="ch">open</span><span class="fu">)</span> <span class="op">-&gt;</span> <span class="ch">processing</span><span class="fu">;</span></a>
<a class="sourceLine" id="cb5-8" title="8"><span class="fu">next_status(</span><span class="ch">processing</span><span class="fu">)</span> <span class="op">-&gt;</span> <span class="ch">closed</span><span class="fu">;</span></a>
<a class="sourceLine" id="cb5-9" title="9"><span class="fu">next_status(</span><span class="ch">closed</span><span class="fu">)</span> <span class="op">-&gt;</span> <span class="ch">invalid</span><span class="fu">;</span></a></code></pre></div>
<p>At a glance, this code seems to have a few problems:</p>
<ul>
<li><code>next_status/1</code> handles <code>open</code> even though it’s not enumerated in the <code>status()</code> type.</li>
<li><code>next_status(closed)</code> returns <code>invalid</code> which isn’t in the <code>status()</code> type.</li>
</ul>
<p>But when we run <code>dialyzer dial2.erl</code>, it doesn’t have anything to say about it:</p>
<pre class="example"><code>  Proceeding with analysis... done in 0m0.10s
done (passed successfully)
</code></pre>
<p>It turns out the second problem can be caught by turning on <code>-Woverspecs</code> (disabled by default), which checks if we’ve overspecified a type, meaning the success typing contains variants that are not included in the spec.<span><label for="sn-4" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-4" class="margin-toggle" /><span class="sidenote">The Dialyzer guide unfortunately doesn’t recommend using the <code>-Woverspecs</code> option, because it has the tendency to overgeneralize the success typings (e.g., to <code>any()</code>).<br />
<br />
</span></span></p>
<p>The first problem highlights that Dialyzer is only looking for errors and not necessarily enforcing our specs. In this case, there’s no path to the <code>open</code> function head, so it’s not considered a problem.</p>
<p>Another example<span><label for="sn-5" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-5" class="margin-toggle" /><span class="sidenote">Based on this Stack Overflow answer: <a href="https://stackoverflow.com/a/49094234">https://stackoverflow.com/a/49094234</a><br />
<br />
</span></span>, which also returns no warnings by default, exhibits other limitations of Dialyzer:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode erlang"><code class="sourceCode erlang"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">-module</span><span class="fu">(</span><span class="ch">dial3</span><span class="fu">).</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="kw">-export</span><span class="fu">([</span><span class="ch">foo</span><span class="op">/</span><span class="dv">0</span><span class="fu">,</span> <span class="ch">myand</span><span class="op">/</span><span class="dv">2</span><span class="fu">]).</span></a>
<a class="sourceLine" id="cb7-3" title="3"></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="fu">foo()</span> <span class="op">-&gt;</span> <span class="fu">myand({</span><span class="ch">a</span><span class="fu">,</span><span class="ch">b</span><span class="fu">},</span> <span class="fu">[</span><span class="dv">1</span><span class="fu">,</span><span class="dv">2</span><span class="fu">]).</span></a>
<a class="sourceLine" id="cb7-5" title="5"></a>
<a class="sourceLine" id="cb7-6" title="6"><span class="fu">myand(</span><span class="ch">true</span><span class="fu">,</span> <span class="ch">true</span><span class="fu">)</span> <span class="op">-&gt;</span> <span class="ch">true</span><span class="fu">;</span></a>
<a class="sourceLine" id="cb7-7" title="7"><span class="fu">myand(</span><span class="ch">false</span><span class="fu">,</span> <span class="va">_</span><span class="fu">)</span> <span class="op">-&gt;</span> <span class="ch">false</span><span class="fu">;</span></a>
<a class="sourceLine" id="cb7-8" title="8"><span class="fu">myand(</span>_<span class="fu">,</span> <span class="ch">false</span><span class="fu">)</span> <span class="op">-&gt;</span> <span class="ch">false</span><span class="fu">.</span></a></code></pre></div>
<p>The problem here is the use of <code>_</code>. Based on the three clauses, Dialyzer infers that the first argument may be <code>true</code>, <code>false</code> or <code>any()</code>, and likewise, the second argument may be <code>true</code>, <code>any()</code> or <code>false</code>. This generalizes to <code>myand(any(), any())</code>, which explains why the call is allowed.<span><label for="sn-6" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-6" class="margin-toggle" /><span class="sidenote">Here, there is again a solution in that we can add a type spec to the function to constrain the types: <code>-spec myand(bool(), bool()) -&gt;
  bool().</code> It’s also possible to use guards.<br />
<br />
</span></span></p>
<p>Dialyzer is not a static type system</p>
<p>So ultimately, while incredibly useful in finding errors in Erlang code and evidence that success typings can be effectively used to statically analyze a dynamically-typed language, Dialyzer is not a replacement for a static type system, nor does it intend to be one. That would require big changes to Erlang’s language semantics.</p>
<p>A new language could have different semantics that support a more robust type system which proves correctness.</p>
<h2 id="statically-typed-beam-languages">Statically-typed BEAM languages</h2>
<p>I’ve found a handful of experimental languages out there:</p>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Language</th>
<th>Compiles To</th>
<th>Tooling</th>
<th>Status</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://github.com/alpaca-lang/alpaca">Alpaca</a></td>
<td>Custom, inspired by OCaml, Elm</td>
<td>BEAM byte-code</td>
<td>Erlang (rebar)</td>
<td>Partially implemented</td>
</tr>
<tr class="even">
<td><a href="https://github.com/kjnilsson/fez">fez</a></td>
<td>F#</td>
<td>Core Erlang</td>
<td>Erlang (erlc)</td>
<td>Experiment</td>
</tr>
<tr class="odd">
<td><a href="https://github.com/wende/elchemy">Elchemy</a></td>
<td>Elm-based</td>
<td>Elixir source</td>
<td>Elm/Elixir</td>
<td>Active development</td>
</tr>
<tr class="even">
<td><a href="https://github.com/lpil/gleam">Gleam</a></td>
<td>Custom, inspired by Elixir, Rust</td>
<td>??</td>
<td>Erlang (rebar)</td>
<td>Early development</td>
</tr>
<tr class="odd">
<td><a href="https://github.com/purerl/purescript">purerl/PureScript</a></td>
<td>PureScript</td>
<td>Erlang source</td>
<td>PureScript/Erlang (psc-package, etc.)</td>
<td>Active development</td>
</tr>
</tbody>
</table>
<h3 id="comparison-of-the-static-type-systems">Comparison of the Static Type Systems</h3>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Pure</th>
<th>Algebraic Data Types</th>
<th>Immutable Data</th>
<th>Type Classes</th>
<th>Evaluation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://github.com/alpaca-lang/alpaca">Alpaca</a></td>
<td>No</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><a href="https://github.com/kjnilsson/fez">fez</a></td>
<td>No</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><a href="https://github.com/wende/elchemy">Elchemy</a></td>
<td>Yes, based on Elm</td>
<td>Yes</td>
<td></td>
<td></td>
<td>Strict</td>
</tr>
<tr class="even">
<td><a href="https://github.com/lpil/gleam">Gleam</a></td>
<td>No (?)</td>
<td>Yes</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><a href="https://github.com/purerl/purescript">purerl/PureScript</a></td>
<td>Yes</td>
<td>Yes</td>
<td></td>
<td></td>
<td>Strict, by default</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>(If I’ve mischaracterized any of these, please let me know!)</p>
<h2 id="making-it-successful">Making it successful</h2>
<h3 id="dont-reinvent-the-wheel">Don’t reinvent the wheel</h3>
<p>Find a way to share existing tools, compilers, community.</p>
<h3 id="language-specification">Language Specification</h3>
<p>Have one</p>
<h3 id="good-ffi">Good FFI</h3>
<p>Needs to be possible and easy to work with Erlang modules.</p>
<h2 id="dealing-with-side-effects">Dealing with Side Effects</h2>
<p><a href="https://github.com/lpil/gleam">https://github.com/lpil/gleam</a> <a href="https://github.com/purerl/purescript">https://github.com/purerl/purescript</a></p>

      </section>
    </article>

    <section>
      <footer>
  &copy; 2019 Nick Reynolds
  <br />

  <a href="mailto:ndreynolds@gmail.com">Email</a> /
  <a href="https://github.com/ndreynolds">GitHub</a> /
  <a href="https://keybase.io/ndreynolds">Keybase</a> /
  <a href="http://ndreynolds.com">ndreynolds.com</a>
  <br />

  <a href="../rss.xml">RSS Feed</a>
  <br />

  Generated by <a href="http://jaspervdj.be/hakyll/">hakyll</a>.
</footer>

    </section>
  </body>
</html>
